using System;
using Unity.Collections;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation
{
    /// <summary>
    /// Represents a visual marker, like a QR code or an AprilTag, that has been detected in the physical environment.
    /// </summary>
    /// <remarks>
    /// Generated by the <see cref="ARMarkerManager"/> when an AR device detects a marker in the environment.
    ///
    /// Related information: <a href="xref:arfoundation-markers-armarker">AR Marker component</a>
    /// </remarks>
    [DefaultExecutionOrder(ARUpdateOrder.k_Marker)]
    [DisallowMultipleComponent]
    [HelpURL(typeof(ARMarker))]
    public class ARMarker : ARTrackable<XRMarker, ARMarker>
    {
        /// <summary>
        /// The physical size of the detected marker in meters.
        /// </summary>
        /// <remarks>
        /// This value represents the width and height of the marker. The X component (size.x) represents the width and
        /// corresponds to the marker's local X-axis. The Y component (size.y) represents the height and corresponds to the
        /// marker's local Z-axis.
        /// </remarks>
        public Vector2 size => sessionRelativeData.size;

        /// <summary>
        /// The type of the detected marker.
        /// </summary>
        /// <remarks>
        /// This indicates the family of the marker, such as <see cref="XRMarkerType.QRCode"/> or
        /// <see cref="XRMarkerType.ArUco"/>. You can use this to handle different types of markers in your application.
        /// </remarks>
        public XRMarkerType markerType => sessionRelativeData.markerType;

        /// <summary>
        /// A numerical identifier for the marker, specific to its type.
        /// </summary>
        /// <remarks>
        /// For the `ArUco` or `AprilTag` marker types, gets the numerical ID encoded in the tag.
        /// For other types, this value isn't relevant.
        /// </remarks>
        public int markerId => sessionRelativeData.markerId;

        /// <summary>
        /// Provides metadata that describes the embedded data available for this marker, such as its type.
        /// </summary>
        /// <remarks>
        /// To get the encoded data, you should first inspect the <see cref="XRSpatialBuffer.bufferType"/> property of the
        /// returned buffer.
        /// Based on the buffer type, you can then call the appropriate method to retrieve the data, such as
        /// <see cref="TryGetStringData"/> for text based encoded data or
        /// <see cref="TryGetBytesData(Allocator)"/> for binary data.
        ///
        /// For convenience, if you already know the expected encoded data type (for example, you are only scanning QR codes
        /// with URLs), you can call <see cref="TryGetStringData"/> directly without first checking this buffer.
        /// </remarks>
        public XRSpatialBuffer dataBuffer => sessionRelativeData.dataBuffer;

        /// <summary>
        /// Attempts to get the encoded data of a specific marker, decoded as a string.
        /// </summary>
        /// <remarks>
        /// To determine if a marker's encoded data is available as a string, you can check its
        /// <see cref="ARMarker.dataBuffer"/> property. If the <see cref="XRSpatialBuffer.bufferType"/> is
        /// <see cref="XRSpatialBufferType.String"/>, this method should be used to retrieve the encoded data.
        ///
        /// Alternatively, if you expect string data (for example, you are scanning QR codes with URLs), you can
        /// call this method directly and check the <see cref="Result{T}.status"/> to see if it was successful.
        /// </remarks>
        /// <returns>
        /// A `Result` which contains the decoded string if successful.
        /// </returns>
        /// <exception cref="System.InvalidOperationException"> Thrown if the required <see cref="ARMarkerManager"/>
        /// instance cannot be found.
        /// </exception>
        public Result<string> TryGetStringData()
        {
            if (ARMarkerManager.instance is ARMarkerManager manager)
                return manager.TryGetStringData(this);

            throw new InvalidOperationException("An active ARMarkerManager is required to get a marker's encoded data, but the " +
                "ARMarkerManager.instance was not found. Ensure an ARMarkerManager is active and enabled in your scene.");
        }

        /// <summary>
        /// Attempts to get the encoded data of a specific marker, decoded as a byte array.
        /// </summary>
        /// <remarks>
        /// To determine if a marker's encoded data is available as binary data, you can check its
        /// <see cref="ARMarker.dataBuffer"/> property. If the <see cref="XRSpatialBuffer.bufferType"/> is
        /// <see cref="XRSpatialBufferType.Uint8"/>, this method should be used to retrieve the encoded data.
        ///
        /// This method allocates a new managed `byte[]` on each successful call. For performance critical applications
        /// that need to avoid garbage collection, consider using the (<see cref="TryGetBytesData(Allocator)"/>).
        /// </remarks>
        /// <returns>
        /// A `Result` which contains the raw byte array if successful.
        /// </returns>
        /// <exception cref="System.InvalidOperationException"> Thrown if the required <see cref="ARMarkerManager"/>
        /// instance cannot be found.
        /// </exception>
        public Result<byte[]> TryGetBytesData()
        {
            if (ARMarkerManager.instance is ARMarkerManager manager)
                return manager.TryGetBytesData(this);

            throw new InvalidOperationException("An active ARMarkerManager is required to get a marker's encoded data, but the " +
                "ARMarkerManager.instance was not found. Ensure an ARMarkerManager is active and enabled in your scene.");
        }

        /// <summary>
        /// Attempts to get the encoded data of a specific marker, decoded as a <see cref="NativeArray{Byte}"/>.
        /// </summary>
        /// <remarks>
        /// This method is useful for performance sensitive applications as it avoids managed memory allocations.
        /// The caller is responsible for disposing the returned <see cref="NativeArray{Byte}"/> for persistent allocators.
        /// </remarks>
        /// <param name="allocator">The allocator to use for the returned <see cref="NativeArray{Byte}"/>.</param>
        /// <returns>A `Result` containing the raw bytes in a <see cref="NativeArray{Byte}"/> if the operation is
        /// successful.</returns>
        /// <exception cref="System.InvalidOperationException"> Thrown if the required <see cref="ARMarkerManager"/>
        /// instance cannot be found.
        /// </exception>
        public Result<NativeArray<byte>> TryGetBytesData(Allocator allocator)
        {
            if (ARMarkerManager.instance is ARMarkerManager manager)
                return manager.TryGetBytesData(this, allocator);

            throw new InvalidOperationException("An active ARMarkerManager is required to get a marker's encoded data, but the " +
                "ARMarkerManager.instance was not found. Ensure an ARMarkerManager is active and enabled in your scene.");
        }
    }
}
